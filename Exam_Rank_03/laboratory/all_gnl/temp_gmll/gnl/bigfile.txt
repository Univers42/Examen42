/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:31:16 by dlesieur          #+#    #+#             */
/*   Updated: 2025/09/17 13:51:52 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "gnl.h"

#ifndef BUFFER_SIZE
# define BUFFER_SIZE 1024
#endif

# define NEWLINE '\n'

char	*extract_line_from_memory(char **memory, size_t *mem_len)
{
	size_t	line_len;
	char	*newline_pos;
	char	*line;
	size_t	leftover_len;
	char	*tmp;

    if (!*memory || *mem_len == 0)
        return NULL;
    newline_pos = ft_strchr(*memory, NEWLINE);
    if (!newline_pos)
        return NULL;
    line_len = newline_pos - *memory + 1;
    line = malloc(line_len + 1);
    if (!line)
        return NULL;
    ft_memmove(line, *memory, line_len);
    line[line_len] = '\0';
    leftover_len = *mem_len - line_len;
    tmp = NULL;
    if (leftover_len > 0)
    {
        tmp = malloc(leftover_len + 1);
        if (tmp)
        {
            ft_memmove(tmp, *memory + line_len, leftover_len);
            tmp[leftover_len] = '\0';
        }
    }
    if (*memory)
        free(*memory);
    *memory = tmp;
    *mem_len = leftover_len;
    return (line);
}

char	*read_and_append_data(int fd, char **memory, size_t *mem_len, size_t *mem_cap)
{
	char	chunk[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	char	*tmp;
	char	*line;
	size_t	cap;

	bytes_read = read(fd, chunk, BUFFER_SIZE);
	if (bytes_read <= 0)
	{
		if (*memory && **memory)
		{
			line = *memory;
			*memory = NULL;
			*mem_len = 0;
			*mem_cap = 0;
			return (line);
		}
		return (NULL);
	}
	chunk[bytes_read] = '\0';
	if (*mem_len + bytes_read + 1 > *mem_cap)
	{
		if (*mem_cap)
			cap = *mem_cap * 2;
		else
			cap = BUFFER_SIZE * 2;
		while (cap < *mem_len + bytes_read + 1)
			cap *= 2;
		tmp = ft_realloc(*memory, *mem_len, cap);
		if (!tmp)
			return (NULL);
		*memory = tmp;
		*mem_cap = cap;
	}
	ft_memmove(*memory + *mem_len, chunk, bytes_read);
	*memory[*mem_len + bytes_read] = '\0';
	*mem_len += bytes_read;
	return (NULL);
}

char *get_next_line(int fd)
{
    static char		*raw_datas = NULL;
    static size_t	mem_len = 0;
    static size_t	mem_cap = 0;
    char			*line;

	line = NULL;
    if (BUFFER_SIZE <= 0 || fd < 0)
        return (NULL);
    while (!line)
    {
        line = extract_line_from_memory(&raw_datas, &mem_len);
        if (!line)
            line = read_and_append_data(fd, &raw_datas, &mem_len, &mem_cap);
        if (!raw_datas && !line)
            return (NULL);
    }
    return line;
}

int main(int argc, char **argv)
{
    int fd;
    char *line;

    if (argc != 2)
    {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    while ((line = get_next_line(fd)))
    {
        printf("%s", line);
        if (line[strlen(line) - 1] != '\n')
            printf("\n");
        free(line);
    }
    close(fd);
    return 0;
}
